import "./chunk-6TJCVOLN.js";

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/Utils.js
var validEvents = [
  "onActivate",
  "onAddUndo",
  "onBeforeAddUndo",
  "onBeforeExecCommand",
  "onBeforeGetContent",
  "onBeforeRenderUI",
  "onBeforeSetContent",
  "onBeforePaste",
  "onBlur",
  "onChange",
  "onClearUndos",
  "onClick",
  "onContextMenu",
  "onCopy",
  "onCut",
  "onDblclick",
  "onDeactivate",
  "onDirty",
  "onDrag",
  "onDragDrop",
  "onDragEnd",
  "onDragGesture",
  "onDragOver",
  "onDrop",
  "onExecCommand",
  "onFocus",
  "onFocusIn",
  "onFocusOut",
  "onGetContent",
  "onHide",
  "onInit",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onLoadContent",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onNodeChange",
  "onObjectResizeStart",
  "onObjectResized",
  "onObjectSelected",
  "onPaste",
  "onPostProcess",
  "onPostRender",
  "onPreProcess",
  "onProgressState",
  "onRedo",
  "onRemove",
  "onReset",
  "onSaveContent",
  "onSelectionChange",
  "onSetAttrib",
  "onSetContent",
  "onShow",
  "onSubmit",
  "onUndo",
  "onVisualAid"
];
var isValidKey = function(key) {
  return validEvents.map(function(event) {
    return event.toLowerCase();
  }).indexOf(key.toLowerCase()) !== -1;
};
var bindHandlers = function(initEvent, listeners, editor) {
  Object.keys(listeners).filter(isValidKey).forEach(function(key) {
    var handler = listeners[key];
    if (typeof handler === "function") {
      if (key === "onInit") {
        handler(initEvent, editor);
      } else {
        editor.on(key.substring(2), function(e) {
          return handler(e, editor);
        });
      }
    }
  });
};
var bindModelHandlers = function(ctx, editor) {
  var modelEvents = ctx.$props.modelEvents ? ctx.$props.modelEvents : null;
  var normalizedEvents = Array.isArray(modelEvents) ? modelEvents.join(" ") : modelEvents;
  editor.on(normalizedEvents ? normalizedEvents : "change input undo redo", function() {
    ctx.$emit("input", editor.getContent({ format: ctx.$props.outputFormat }));
  });
};
var initEditor = function(initEvent, ctx, editor) {
  var value = ctx.$props.value ? ctx.$props.value : "";
  var initialValue = ctx.$props.initialValue ? ctx.$props.initialValue : "";
  editor.setContent(value || (ctx.initialized ? ctx.cache : initialValue));
  ctx.$watch("value", function(val, prevVal) {
    if (editor && typeof val === "string" && val !== prevVal && val !== editor.getContent({ format: ctx.$props.outputFormat })) {
      editor.setContent(val);
    }
  });
  if (ctx.$listeners.input) {
    bindModelHandlers(ctx, editor);
  }
  bindHandlers(initEvent, ctx.$listeners, editor);
  ctx.initialized = true;
};
var unique = 0;
var uuid = function(prefix) {
  var time = Date.now();
  var random = Math.floor(Math.random() * 1e9);
  unique++;
  return prefix + "_" + random + unique + String(time);
};
var isTextarea = function(element) {
  return element !== null && element.tagName.toLowerCase() === "textarea";
};
var normalizePluginArray = function(plugins) {
  if (typeof plugins === "undefined" || plugins === "") {
    return [];
  }
  return Array.isArray(plugins) ? plugins : plugins.split(" ");
};
var mergePlugins = function(initPlugins, inputPlugins) {
  return normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins));
};
var isNullOrUndefined = function(value) {
  return value === null || value === void 0;
};

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/ScriptLoader.js
var createState = function() {
  return {
    listeners: [],
    scriptId: uuid("tiny-script"),
    scriptLoaded: false
  };
};
var CreateScriptLoader = function() {
  var state = createState();
  var injectScriptTag = function(scriptId, doc, url, callback) {
    var scriptTag = doc.createElement("script");
    scriptTag.referrerPolicy = "origin";
    scriptTag.type = "application/javascript";
    scriptTag.id = scriptId;
    scriptTag.src = url;
    var handler = function() {
      scriptTag.removeEventListener("load", handler);
      callback();
    };
    scriptTag.addEventListener("load", handler);
    if (doc.head) {
      doc.head.appendChild(scriptTag);
    }
  };
  var load = function(doc, url, callback) {
    if (state.scriptLoaded) {
      callback();
    } else {
      state.listeners.push(callback);
      if (!doc.getElementById(state.scriptId)) {
        injectScriptTag(state.scriptId, doc, url, function() {
          state.listeners.forEach(function(fn) {
            return fn();
          });
          state.scriptLoaded = true;
        });
      }
    }
  };
  var reinitialize = function() {
    state = createState();
  };
  return {
    load,
    reinitialize
  };
};
var ScriptLoader = CreateScriptLoader();

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/TinyMCE.js
var getGlobal = function() {
  return typeof window !== "undefined" ? window : global;
};
var getTinymce = function() {
  var global2 = getGlobal();
  return global2 && global2.tinymce ? global2.tinymce : null;
};

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/components/EditorPropTypes.js
var editorProps = {
  apiKey: String,
  cloudChannel: String,
  id: String,
  init: Object,
  initialValue: String,
  inline: Boolean,
  modelEvents: [String, Array],
  plugins: [String, Array],
  tagName: String,
  toolbar: [String, Array],
  value: String,
  disabled: Boolean,
  tinymceScriptSrc: String,
  outputFormat: {
    type: String,
    validator: function(prop) {
      return prop === "html" || prop === "text";
    }
  }
};

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/components/Editor.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var renderInline = function(h, id, tagName) {
  return h(tagName ? tagName : "div", {
    attrs: { id }
  });
};
var renderIframe = function(h, id) {
  return h("textarea", {
    attrs: { id },
    style: { visibility: "hidden" }
  });
};
var initialise = function(ctx) {
  return function() {
    var finalInit = __assign(__assign({}, ctx.$props.init), { readonly: ctx.$props.disabled, selector: "#" + ctx.elementId, plugins: mergePlugins(ctx.$props.init && ctx.$props.init.plugins, ctx.$props.plugins), toolbar: ctx.$props.toolbar || ctx.$props.init && ctx.$props.init.toolbar, inline: ctx.inlineEditor, setup: function(editor) {
      ctx.editor = editor;
      editor.on("init", function(e) {
        return initEditor(e, ctx, editor);
      });
      if (ctx.$props.init && typeof ctx.$props.init.setup === "function") {
        ctx.$props.init.setup(editor);
      }
    } });
    if (isTextarea(ctx.element)) {
      ctx.element.style.visibility = "";
      ctx.element.style.display = "";
    }
    getTinymce().init(finalInit);
  };
};
var Editor = {
  props: editorProps,
  created: function() {
    this.elementId = this.$props.id || uuid("tiny-vue");
    this.inlineEditor = this.$props.init && this.$props.init.inline || this.$props.inline;
    this.initialized = false;
  },
  watch: {
    disabled: function() {
      this.editor.setMode(this.disabled ? "readonly" : "design");
    }
  },
  mounted: function() {
    this.element = this.$el;
    if (getTinymce() !== null) {
      initialise(this)();
    } else if (this.element && this.element.ownerDocument) {
      var channel = this.$props.cloudChannel ? this.$props.cloudChannel : "5";
      var apiKey = this.$props.apiKey ? this.$props.apiKey : "no-api-key";
      var scriptSrc = isNullOrUndefined(this.$props.tinymceScriptSrc) ? "https://cdn.tiny.cloud/1/" + apiKey + "/tinymce/" + channel + "/tinymce.min.js" : this.$props.tinymceScriptSrc;
      ScriptLoader.load(this.element.ownerDocument, scriptSrc, initialise(this));
    }
  },
  beforeDestroy: function() {
    if (getTinymce() !== null) {
      getTinymce().remove(this.editor);
    }
  },
  deactivated: function() {
    var _a;
    if (!this.inlineEditor) {
      this.cache = this.editor.getContent();
      (_a = getTinymce()) === null || _a === void 0 ? void 0 : _a.remove(this.editor);
    }
  },
  activated: function() {
    if (!this.inlineEditor && this.initialized) {
      initialise(this)();
    }
  },
  render: function(h) {
    return this.inlineEditor ? renderInline(h, this.elementId, this.$props.tagName) : renderIframe(h, this.elementId);
  }
};

// node_modules/@tinymce/tinymce-vue/lib/es2015/main/ts/index.js
var ts_default = Editor;
export {
  ts_default as default
};
//# sourceMappingURL=@tinymce_tinymce-vue.js.map
